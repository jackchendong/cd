小知识点:
        /***cmd编译.cs文件为.exe可执行应用程序:
                    1：C:\Windows\Microsoft.NET\Framework\ -- 下面有很多版本用最新得就行 找到 csc.exe 文件 配置环境变量
                    2：在cmd中敲命令： csc [.cs文件路径]  就会在同目录下生成同名得.exe 文件
                    3：        在cmd中直接运行.exe文件  c:> [.exe文件路径]
                            双击.exe文件  -- 但是会闪一下
                    解析csc 命令的作用:
                            首先要检查源文件中的代码是否符合C#语言规范. 如果符合 那么就将源代码生产为1个可执行文件.
                            如果不符合 就会提示错误 并大概的提示错误发生的地方  不会生产可执行文件.
        /***设置启动项目:  -- 这样得话方便
		            找到解决方案--》右击属性--》设置启动项 选择当前选定内容

        /***CPU只会执行Main函数中的代码. 当CPU将Main函数中的代码执完毕以后,那么程序就自动结束了.main函数即使入口也是出口

        /*** Console.ReadLine(),Console.ReadKey()  -- 暂停控制台程序

        /***c#源代码 --> 程序集(exe,dll)  MSIL(微软中间语言)  -- > CLR公共语言运行时 (JIT即时编译器)  --> cpu
             c#编译器得作用：先检查源文件的语法是否正确。若正确就生成程序集
             程序集：只有.NET平台编译出来的.exe或dll才叫程序集，不是所有的exe,dll文件都叫程序集,
                    组成程序集的重要部分是MSIL

        /***利用.NET reflector 可以反向编译
        /***ILDASM可以用这个工具看程序集的中间语言是什么
         /***托管代码与非托管代码
                托管代码：运行的时候被CLR托管的代码，叫做托管代码
                非托管代码：运行的时候直接被系统运行
                区别：
                    1：安全性 
                        托管代码更为安全
                        托管代码开个空间，防止别的程序进来，限制自己出去这样安全
                    2：效率
                        托管代码大多数情况下运行效率比非托管代码高。因为程序集在运行的时候，JIT（根据环境，CPU。。。）会将程序集中的MSIL于洋
                        转换本地平台执行效率最高的二进制代码 
                        在第一次运行的时候，托管代码的效率比较低，只要系统不关闭
                    3：内存的管理
                        托管代码自动回收，非托管代码要主动释放。
        /***vs代码段的使用
                工具--》代码段管理器语言 选c# 出来路径 在路径下面就是放的代码段。
                自定义：按照其中之一的格式就可以了
        /***控制台接受用户的输入
                String  a=Console.ReadLine();
                ConsoleKeyInfo k=Console.ReadKey(); --  k.key  k.char
        /***Console.WriteLine()的占位符
                ex: Console.WriteLine("我{0},{1}","是","啊啊啊");
                                    第一个变量是0 ， 第二个是1 ... 
                     Console.WriteLine("我{0},{0}","是","啊啊啊");  -- 这样也行，只是有个变量没有用。
        /***c#中的注释
                1:单行注释  //
                2：多行注释  /*
                             * 
                             */
                3：文档注释
                        ///<summary>
                        /// 这是注释字符
                        ///</summary>
                4.折叠注释
                        #regin 注释字符
                        #endregin
                                
1：数据类型
    数值类型：
        整型：
            类型	    描述	                    范围	            默认值
            long	64 位有符号整数类型	-923,372,036,854,775,808 到 9,223,372,036,854,775,807	0L
            int	    32 位有符号整数类型	-2,147,483,648 到 2,147,483,647	0
            short	16 位有符号整数类型	-32,768 到 32,767	0
            sbyte	8 位有符号整数类型	-128 到 127	0
            byte	8 位无符号整数	  0 到 255  	0
            uint	32 位无符号整数类型	0 到 4,294,967,295	0
            ulong	64 位无符号整数类型	0 到 18,446,744,073,709,551,615	0
            ushort	16 位无符号整数类型	0 到 65,535	0
            char	16 位 Unicode 字符	U +0000 到 U +ffff	'\0'

        浮点型：
            类型	    描述	           范围	            默认值
            decimal	128 位精确的十进制值，28-29 有效位数	(-7.9 x 1028 到 7.9 x 1028) / 100 到 28	0.0M
                注意：decimal类型的数据不能和其它的浮点型的数据参与算数运算
                      因为decimal类型的数据范围低，但是精度高。-- 懂？会丢失精度
                      但是可以和其他整形的数据参与算数运算。
            double	64 位双精度浮点型	(+/-)5.0 x 10-324 到 (+/-)1.7 x 10-308	0.0D
            float	32 位单精度浮点型	-3.4 x 10-38 到 + 3.4 x 10-38	0.0F
                注意：如果我们直接在代码中写一个小数默认是double类型
                double范围最广
                decimal精度最高
            
    bool类型：
            boole

    string类型：
            char：
                	16 位 Unicode 字符	U +0000 到 U +ffff	'\0'
                    char可以存储单个字符，要用单引号引起来，空格也算字符
                    char类型的数据可以参与算数运算
            string ：
                存储多个字符，要用双引号引起来，可以没有也可以一个



2:变量
    命名规则：
        1：以字母,_,@  开头不能以数字开头
        2：后面可以跟字母，数字，下划线
        3：驼峰命名，第一个小写其余单词首字母大写
        4：英文单词的缩写全大写
        5：c#大小写敏感
3：运算符和算数表达式和条件表达式
        注意：char类型的数据可以做算数运算，系统会将char类型的数据转成Unicode码再运算
        =  ：赋值运算符，将左边的值给右边的变量
        +  ：1：在字符串运算的时候是拼接字符串
             2：在做算数运算的时候是求和运算
        *

        / ：
            ex：int i =10;
                int j=3;
                i/j -- 结果不是小数，两个都是int 则算出来的就是int类型
        %
        +=,-=,*=,/=,%=
        ++ 自增
        -- 自减
        
        条件运算符：
            >
            >=
            <
            <=
            ==
            !=
            注意： < <= > >=只能比较数值类型和char类型的数据
                    ==  != 所有的数据都可以比较
                    要比较就类型要一致或着兼容：
                        ex: string str ="123";
                            int i = 123;
                            str == i ;//报错 数据类型不兼容
        条件表达式：
            表达式的结果为bool值

        逻辑运算符：
            && : 逻辑与
            || : 逻辑或
            !  : 逻辑非
            

        算数表达式：
            算数表达式的结果类型？
                如果算数表达式的数据的类型一致，那么这个算数表达式的结果也是这个类型。
                如果不一致，那么表达式的类型是范围最大的那个。
            注意：浮点型的范围比整型的大
                  浮点型>long>int>short>byte
            ex: int i1=2100000000
                int i2=2100000000
                long i3=i1+i2    //结果不是42亿，因为表达式的结果为int类型 42亿溢出了。结果不是我们想要的
4:转义
        \n : 换行
        \b : 删除前面的字符
        \\ : 就是字符\
        \t : 制表符
        \r : 回车
        注意：字符串的前面加@之后，字符串可以换行，并且无论什么转义都会当字符串使用。

5：数据的转换
    1：自动转换（隐式转换）
        自动转换的条件：
            1：两种变量的数据类型相互兼容，所有的值类型之间相互兼容
            2：目标类型的范围要比源类型的范围大
                    注意：char类型的数据与数值类型兼容。char 相当于 int 类型
                    范围 ： double > decimal > float
            ex: byte b = 12
                int i = b  // 隐式转换   
    2：强制转换
        类型兼容：
            再数据类型兼容的情况下，我们不能直接将一个范围类型的变量直接赋值给1个小范围的数据类型的变量。因为有可能溢出。
            所以系统不直接帮我们转换。
            语法：
                小范围变量 = (强制转换的类型) 大范围的变量 
                ex: int i=20;
                    byte b = (byte) i;

                    int i = 97;
                    char c=(char) i; //a 成立
            强制转换溢出的情况：
                1：浮点型 -> 整型  只保留整数部分
                2：大 - > 小
                    ex: int i=268;
                        byte b= i ;//2 结果是溢出的部分。
        
        类型不兼容：
            parse转换：用来将字符串转成其他类型
            转换成功的条件：
                1：字符串的字面量是什么类型就转换成什么类型
                2：parse 只能转换字符串  -- char 类型的也报错
                    语法：
                        ex: String str = "123";
                        int num = int.Parse(str);

                        ex: string str = "123.123f";
                            float d= float.Parse(str); //报错
            
            convert转换：万能转化任意的数据都能用convert
                语法：
                    Convert.To类型(待转数据);
                              int === > int32
                              long ===> int64
                              short ===> int16
                              float ===> single
                                其他类型一致
                    ex : String str = "123" ;
                         int num = Convert.ToInt64(str);
                    
                    Convert与parse 的区别
                        1：convert 内部调用了parse 转换只是在前面添加了一个判断
                            ex:string str= null;
                            Int a =Convert.ToInt32(str)  //a =0;
                                但是parse转换则会报错
                        2：convert转换还可以做自动类型的转换，于直接赋值一样。
                            ex: byte b =12 ;
                                int i = Convert.ToInt32(b);
                                但是parse则会报错。
                        3：convert做强制转换：
                            ex: int i = 256;
                                byte b = Convert.ToByte(i)  // 会报错
                                发生溢出就报错。但是强制转换就不会报错。结果不是我们想要的就是了
                            将浮点型强制转换为整型：convert会对小数部分做4舍5入。但是 <= 0.5 都是舍
                                但是强制转换全部是舍。舍掉小数部分。
                            ex: 
                                double d = 12.51;
                                int i = Convert.int32(5) ; // 13
            
            tostring : 任意数据都能转成字符串 
                    语法： 
                       String str = 变量.ToString();

            




                     