小知识点:
        /***cmd编译.cs文件为.exe可执行应用程序:
                    1：C:\Windows\Microsoft.NET\Framework\ -- 下面有很多版本用最新得就行 找到 csc.exe 文件 配置环境变量
                    2：在cmd中敲命令： csc [.cs文件路径]  就会在同目录下生成同名得.exe 文件
                    3：        在cmd中直接运行.exe文件  c:> [.exe文件路径]
                            双击.exe文件  -- 但是会闪一下
                    解析csc 命令的作用:
                            首先要检查源文件中的代码是否符合C#语言规范. 如果符合 那么就将源代码生产为1个可执行文件.
                            如果不符合 就会提示错误 并大概的提示错误发生的地方  不会生产可执行文件.
        /***设置启动项目:  -- 这样得话方便
		            找到解决方案--》右击属性--》设置启动项 选择当前选定内容

        /***ctrl+shift+空格 可以强制提示--在把()打完之后没有提示了，就将光标放到括号里面在按快捷键就有提示了。

        /***CPU只会执行Main函数中的代码. 当CPU将Main函数中的代码执完毕以后,那么程序就自动结束了.main函数即使入口也是出口
        /***声明一个局部变量的时候，声明完以后始终没有用到这个变量那么c#编译器在编译的时候会将这个声明省略掉。
        /***为什么使用面向对象？
            修改维护几位方便。
        /***我们在为类声明字段并赋值的时候，编译器在编译的时候会在构造函数中赋值。
                因为字段赋值的代码，是执行代码，只有CPU执行才会有结果。

        /***面向对象的思维。
                ex:  人开门
                    class Person                class Door                    Main(){
                    {                           {                                    
                     public string name;          public string brand;          Person p =new Person();
                                                                                Door d =new Door();
                     public void OpenDoor(Door d)   public void Open()          p.OpenDoor(d)
                     {                             {
                           d.Open()                  console.log("门开了")
                      }                            }

                    }                             }                                }


        /***c#源代码 --> 程序集(exe,dll)  MSIL(微软中间语言)  -- > CLR公共语言运行时 (JIT即时编译器)  --> cpu
             c#编译器得作用：先检查源文件的语法是否正确。若正确就生成程序集
             程序集：只有.NET平台编译出来的.exe或dll才叫程序集，不是所有的exe,dll文件都叫程序集,
                    组成程序集的重要部分是MSIL

        /***利用.NET reflector 可以反向编译
        /***ILDASM可以用这个工具看程序集的中间语言是什么
         /***托管代码与非托管代码
                托管代码：运行的时候被CLR托管的代码，叫做托管代码
                非托管代码：运行的时候直接被系统运行
                区别：
                    1：安全性 
                        托管代码更为安全
                        托管代码开个空间，防止别的程序进来，限制自己出去这样安全
                    2：效率
                        托管代码大多数情况下运行效率比非托管代码高。因为程序集在运行的时候，JIT（根据环境，CPU。。。）会将程序集中的MSIL于洋
                        转换本地平台执行效率最高的二进制代码 
                        在第一次运行的时候，托管代码的效率比较低，只要系统不关闭
                    3：内存的管理
                        托管代码自动回收，非托管代码要主动释放。
        /***即使窗口的使用
                在调试模式下在即使窗口输入 &变量 就会输出地址。
        /***vs代码段的使用
                工具--》代码段管理器语言 选c# 出来路径 在路径下面就是放的代码段。
                自定义：按照其中之一的格式就可以了
        
        /***c#中的注释
                1:单行注释  //
                2：多行注释  /*
                             * 
                             */
                3：文档注释
                        ///<summary>
                        /// 这是注释字符
                        ///</summary>
                4.折叠注释
                        #regin 注释字符
                        #endregin
        /****计算机的存储
                计算机的存储空间主要分两个：栈空间和堆空间。
                            声明就是在栈空间  //值类型直接存储在栈空间
                            new 就是在堆空间  //引用类型栈空间存的是堆的地址。
        /***对象与类的区别
                对象是具体存在的可以直接使用，类是统称抽象的不能直接使用。
                类是模板，对象是根据这个模板创建出来的，模板上有什么那么对象中也就有什么，不多也不少。
        /***Console类库
                    控制台接受用户的输入
                            String  a=Console.ReadLine();
                            ConsoleKeyInfo k=Console.ReadKey(); --  k.key  k.char
                
                    Console.WriteLine()的占位符
                            ex: Console.WriteLine("我{0},{1}","是","啊啊啊");
                                                第一个变量是0 ， 第二个是1 ... 
                                Console.WriteLine("我{0},{0}","是","啊啊啊");  -- 这样也行，只是有个变量没有用。
                    Console.Clear()   //清空控制台。。
                    Console.Beep();  //通过扬声器播放B的声音一次。默认声音
                    Console.Beep(500,2000); // 第一个参数是声音的频率就是调节是什么声音 ，第二个参数是播放的时常 这里表示2s播放频率为500的声音。
                    Console.Title = "aaaaa";  //设置控制台标题
                    Console.BackgroundColor = ConsoleColor.Blue;  //设置控制台的背景色为蓝色，这个仅针对字体的背景。。。
                    Console.ForegroundColor = ConsoleColor.Red;  //设置前景色，就是字体颜色
                    Console.ReadLine(),Console.ReadKey()  -- 暂停控制台程序

        /***获得随机数
                Random r =new Random();
                int num = r.Next (0,101); //   0=<num<101并且是整数

        /***数组类库
                数组反转:
                        Array.Reverse(arr) //直接改变数组
                判断数组里面时候有'a':
                        bool b= arr.Contains("a")   
                找数组中指定数据的下标:
                        int index = Array.indexOf(arr,"a")  //找到就是下标，没找到就是-1 --找的是最近的一个
                        int a =Array.LastIndexOf(arr,10);  //在有相同数据的情况下找最后一个的下标
                数组排序：
                        Array.Sort(arr);  //升序
                        要降序很简单，先升序，在反转。。。

        /***string类库
                str.Trim()    //去掉字符串的首尾空格。。
                str.TrimStart()  //去掉字符串前面的空格
                str.TrimEnd()   //去掉字符串的末尾的空格
                                
1：数据类型
    值类型： -- 值是在栈里面
            整型：
                类型	    描述	                    范围	            默认值
                long	64 位有符号整数类型	-923,372,036,854,775,808 到 9,223,372,036,854,775,807	0L
                int	    32 位有符号整数类型	-2,147,483,648 到 2,147,483,647	0
                short	16 位有符号整数类型	-32,768 到 32,767	0
                sbyte	8 位有符号整数类型	-128 到 127	0
                byte	8 位无符号整数	  0 到 255  	0
                uint	32 位无符号整数类型	0 到 4,294,967,295	0
                ulong	64 位无符号整数类型	0 到 18,446,744,073,709,551,615	0
                ushort	16 位无符号整数类型	0 到 65,535	0
                char	16 位 Unicode 字符	U +0000 到 U +ffff	'\0'

            浮点型：
                类型	    描述	           范围	            默认值
                decimal	128 位精确的十进制值，28-29 有效位数	(-7.9 x 1028 到 7.9 x 1028) / 100 到 28	0.0M
                    注意：decimal类型的数据不能和其它的浮点型的数据参与算数运算
                        因为decimal类型的数据范围低，但是精度高。-- 懂？会丢失精度
                        但是可以和其他整形的数据参与算数运算。
                double	64 位双精度浮点型	(+/-)5.0 x 10-324 到 (+/-)1.7 x 10-308	0.0D
                float	32 位单精度浮点型	-3.4 x 10-38 到 + 3.4 x 10-38	0.0F
                    注意：如果我们直接在代码中写一个小数默认是double类型
                    double范围最广
                    decimal精度最高
                
            bool类型：
                 boole

            char类型：
                    char：
                            16 位 Unicode 字符	U +0000 到 U +ffff	'\0'
                            char可以存储单个字符，要用单引号引起来，空格也算字符
                            char类型的数据可以参与算数运算
            enum枚举：

            结构：
                    
    引用类型：--值都是在堆里面
            string ：  -- 他的值存在堆里面，但是是个特殊的引用类型！！！
                        存储多个字符，要用双引号引起来，可以没有也可以一个
            数组：
                数组特性：数组中存储的数据类型必须一致，在创建的时候必须指定数组中存储的类型。
                        必须指定数组的长度。
                        数组有下表（索引）。
                语法：类型[] 数组名称=new 类型[存储的长度]; -- 声明数组
                        ex: int[]  arr = new int[3];
                    int[]  arr = new int[3]{1,2,3};    -- 声明并赋值
                    int[]  arr = new int[]{1,2,3,4};   --这里自动指定数组的长度，长度根据初始化器中的个数自动确定。
                    int[] arr= {1,2,3,4,5}              -- 简写
                数组的默认值：
                    数值类型的数组  --> 默认值是0
                    bool值类型的数组 -->默认值是fals
                    char类型的数组  -- > 默认值是'\0' 
                    string类型的数组 -- >默认值是null

            Array:

            class:

2:变量
    命名规则：
        1：以字母,_,@  开头不能以数字开头
        2：后面可以跟字母，数字，下划线
        3：驼峰命名，第一个小写其余单词首字母大写
        4：英文单词的缩写全大写
        5：c#大小写敏感
    变量的作用域：
        在一个大括弧中定义的变量只能在这个括弧中访问，出了大括弧就无法被访问。
        why:
            cpu在执行的过程中。如果执行完一个大括弧，那么大括弧中的变量会被系统垃圾回收。

    局部变量：定义在方法中的变量：只能在当前定义的方法中访问。--一直都是栈中。。
              在使用局部变量之前要赋值才能用。
              ex:  public static void name(){
                        int a =10;  //局部变量
                    }
    成员变量：定义在类中的变量：可以在整个类中访问！！！这个变量在new的时候存在堆中。。。
                成员变量在使用前可以不用赋值。--  使用的时候就是默认值。。
                                            值类型的默认值是:  0
                                           引用类型的默认值是：null
                如果要想被方法直接访问不传值。就可以加前面在static
                ex: 
                    class chen{
                            static int a =10;
                            public static void name(){
                                Console.WriteLine(a)   //这里能拿的到数据
                            }
                    }
                   
3：运算符和算数表达式和条件表达式
        注意：char类型的数据可以做算数运算，系统会将char类型的数据转成Unicode码再运算
        =  ：赋值运算符，将左边的值给右边的变量
        +  ：1：在字符串运算的时候是拼接字符串
             2：在做算数运算的时候是求和运算
        *

        / ：
            ex：int i =10;
                int j=3;
                i/j -- 结果不是小数，两个都是int 则算出来的就是int类型
        %
        +=,-=,*=,/=,%=
        ++ 自增
        -- 自减
        
        条件运算符：
            >
            >=
            <
            <=
            ==
            !=
            注意： <  <=  > >= 只能比较数值类型和char类型的数据
                    ==  != 所有的数据都可以比较
                    要比较就类型要一致或着兼容：
                        ex: string str ="123";
                            int i = 123;
                            str == i ;//报错 数据类型不兼容
        条件表达式：
            表达式的结果为bool值

        逻辑运算符：
            && : 逻辑与 两边的条件表达式都为true最终的结果才为true
                 如果做左边的为false,那么右边的就不会再看了。
                 ex: int i =4;
                     bool b= i++ > 10 && ++i >0;
                     Console.WriteLine(i)  // i=5  因为前面的i++ > 10 为false 所以左边的表达式系统就不会再看了
            || : 逻辑或
                    如果左边的表达式为true，那么右边的表达式就不会再看了。
                                    
            !  : 逻辑非
            逻辑运算符的优先级：! > && > || 
            ex:  int i=12;
                bool b = i +1 > -1 || i < -5  && i <10 ;//结果为true
                          i+1 > -1 ||  (i <-5 && i <10)  //实际先算&& 也就是括号里面的
                                    
        所有运算符的优先级：() > 单目运算符(!,++,--)  > 算数运算符 > 条件运算符 > 逻辑运算符
        算数表达式：
            算数表达式的结果类型？
                如果算数表达式的数据的类型一致，那么这个算数表达式的结果也是这个类型。
                如果不一致，那么表达式的类型是范围最大的那个。
            注意：浮点型的范围比整型的大
                  浮点型>long>int>short>byte
            ex: int i1=2100000000
                int i2=2100000000
                long i3=i1+i2    //结果不是42亿，因为表达式的结果为int类型 42亿溢出了。结果不是我们想要的
4:转义
        \n : 换行
        \b : 删除前面的字符
        \\ : 就是字符\
        \t : 制表符
        \r : 回车
        注意：字符串的前面加@之后，字符串可以换行，并且无论什么转义都会当字符串使用。

5：数据的转换
    1：自动转换（隐式转换）
        自动转换的条件：
            1：两种变量的数据类型相互兼容，所有的值类型之间相互兼容
            2：目标类型的范围要比源类型的范围大
                    注意：char类型的数据与数值类型兼容。char 相当于 int 类型
                    范围 ： double > decimal > float
            ex: byte b = 12
                int i = b  // 隐式转换   
    2：强制转换
        类型兼容：
            再数据类型兼容的情况下，我们不能直接将一个范围类型的变量直接赋值给1个小范围的数据类型的变量。因为有可能溢出。
            所以系统不直接帮我们转换。
            语法：
                小范围变量 = (强制转换的类型) 大范围的变量 
                ex: int i=20;
                    byte b = (byte) i;

                    int i = 97;
                    char c=(char) i; //a 成立
            强制转换溢出的情况：
                1：浮点型 -> 整型  只保留整数部分
                2：大 - > 小
                    ex: int i=268;
                        byte b= i ;//2 结果是溢出的部分。
        
        类型不兼容：
            parse转换：用来将字符串转成其他类型
            转换成功的条件：
                1：字符串的字面量是什么类型就转换成什么类型
                2：parse 只能转换字符串  -- char 类型的也报错
                    语法：
                        ex: String str = "123";
                        int num = int.Parse(str);

                        ex: string str = "123.123f";
                            float d= float.Parse(str); //报错
            
            convert转换：万能转化任意的数据都能用convert
                语法：
                    Convert.To类型(待转数据);
                              int === > int32
                              long ===> int64
                              short ===> int16
                              float ===> single
                                其他类型一致
                    ex : String str = "123" ;
                         int num = Convert.ToInt64(str);
                    
                    Convert与parse 的区别
                        1：convert 内部调用了parse 转换只是在前面添加了一个判断
                            ex:string str= null;
                            Int a =Convert.ToInt32(str)  //a =0;
                                但是parse转换则会报错
                        2：convert转换还可以做自动类型的转换，于直接赋值一样。
                            ex: byte b =12 ;
                                int i = Convert.ToInt32(b);
                                但是parse则会报错。
                        3：convert做强制转换：
                            ex: int i = 256;
                                byte b = Convert.ToByte(i)  // 会报错
                                发生溢出就报错。但是强制转换就不会报错。结果不是我们想要的就是了
                            将浮点型强制转换为整型：convert会对小数部分做4舍5入。但是 <= 0.5 都是舍
                                但是强制转换全部是舍。舍掉小数部分。
                            ex: 
                                double d = 12.51;
                                int i = Convert.int32(5) ; // 13
            
            tostring : 任意数据都能转成字符串 
                    语法： 
                       String str = 变量.ToString();

            

6: if结构，if-else结构，三目运算符，switch-case结构
    if语法：1:
              if(bool表达式){  //表达式的结果为bool类型
                //执行代码
                }
        
           2:if(bool表达式)          // 如果代码里面只有一句代码就可以省略大括号{}
                 执行的一句代码;
              else if (bool表达式)
                  一句代码;
            
            ex:
                if(a>0)          //这样写也是对的
                    if(a>9)
                        console.log("a>9")
                    else
                        console.log("0<a<9")
                else
                    console.log("a<0")
    if-else语法:
                if(bool表达式){

                }else{

                }
    三目运算符：
        语法：  bool表达式?值1:值2
        结果：如果bool表达式的结果为true那么三元表达式的结果为值1，如果bool表达式为false那么结果为值2
        注意：值1和值2的类型要一致。
              值1和值2还可一写成表达式，将表达式的值的值返回。
    switch-case语法：
            注意：case 后面的值 不能有变量的存在。！！！！
            switch(表达式/值/变量){   //这里面不能是浮点型！！！！！！
                case 值1:
                    执行代码1;
                    break;
                case 值2:
                    执行代码2;
                    break;
                case 值3:
                    执行代码3;
                    break;
                default:
                    执行代码;
                    break;
            }

            switch(表达式/值/变量){
                    case 值1:
                    case 值2:
                    case 值3:
                        执行代码;
                        break;
                    default:
                        break;
            }


7：循环结构 while  do-while for foreach
        while:
            语法：while(bool表达式){

                 }
            流程：先计算bool表达式的结果，如果结果为true则执行循环体，直到表达式的结果为false跳出循环。
                  break也可以跳出循环。
            ex:  while(pwd != "888888"){        //将退出条件写在这里。。

                }

        while中的break和continue:
                break:跳出循环
                continue:只能卸载循环体中，作用是立马结束本次循环。进入下一次循环。

        do-while:
            语法：do
                  {
                        //循环体
                  }while(bool表达式);
            流程：先执行一次循环体在判断bool表达式。。。
        for：
            语法：for(初始化表达式;bool表达式;循环操作表达式){
                        //循环体
                    }
            ex:for (int i = 0; i<10 ;i++){

                }
            注意：for循环的三个表达式都可以省略。但是分号不能省略。
                    for (;;){

                    }   // 死循环。
                    第一个表达式可以随便写。！！！
                    如果第二个表达式省略。那么循环的条件就是true。写的话只能是bool表达式。
                    ex:for(Console.WriteLine("A"); ;Console.WriteLine("B")){
                            Console.WriteLine("C")

                        }    // A B C B C B C ...  证明第一个表达式只有第一次执行
                    break在for循环中与while中一样，但是continue有点不同，在for中还是会执行操作表达式。！！！
        
        foreach:
            语法：foreach(数据类型 变量名 in 数组的名称){

                  }
8：try-catch
            try    -- 比较消耗性能
            {
                int b = 0;
                int a = 10 / b;  //这里异常  直接去执行catch的代码
                int c = 11;    //这里不会执行
                
            }
            catch (Exception e)
            {
                Console.WriteLine(e);       //打印全部
                Console.WriteLine(e.message);   //只打印信息
                
            }
            finally     //这个可以没有  无论如何都执行这段代码
            {
                    Console.WriteLine("不管有没有异常都执行"); 
            }

9：方法和return：
        语法:
            访问修饰符  [static(是否是静态的)] 返回值的类型 方法的名称([参数列表])
            {
                //方法体
            }
        位置：不能在Main函数中。应该定义在类中，与Main函数同级别。
        名称：每个单词首字母都大写。
        return :立即结束一个方法，并可以带返回值。return--只能在方法里面用
        方法传参：对于值类型的数据是按值传递，对于引用类型的数据是按地址传递。
                    简单点：按值传递之后的改变不会影响源数据。
                            引用类型的传递的改变就会源也会改变。
        方法中的switch：方法里面有return就不写break
               ex: public static int getresult(){
                    switch ("a"):
                    {
                        case "+":
                                return 10+10;      //不写break
                        case "-":
                                return  10+10;
                        default:
                                return 0;      //因为有返回值所有方法必须有返回值；也可以在外面写return 0;没有影响
                    }
                        
                }
        方法的重载：在一个类中可以定义多个同名的方法，但是必须保证参数的个数或者类型不一样。
                ex: public void name (){

                    };
                    public void name (bool b){

                    }

            

10：关键字：
        static:直接在内存中生成。可以直接在其他地方使用。--一直在内存中存在
                在program类中的成员变量，要想被Main函数访问就得加static.!!!
                    因为Main是static类型的函数。
                但是在其他类里面得成员变量可以不加static就被成员函数访问。
                ex:
                    class Person
                    {
                        private string name;
                        void Sing()
                        {
                            this.name = "陈冬";   //可以直接访问。也可以用实例对象.就可以出来
                        }
                    }
        new:   在内存中开辟空间，实例化类。
                new做的四件事：
                    1：在堆空间中开辟1块合适大小的空间
                    2：在这个空间中根据类的模板来创建对象，类模板中定义了那些成员变量，
                        就按照这个模板来在空间中逐个创建。
                    3：调用这个对象的构造函数。
                    4：返回这个空间的引用地址。
        using：引用命名空间这样就可以直接访问当中的类了。不用加命名空间的前缀了。

        this:指当前对象

        set和get： 属性 属性不能存值。。。实际有点像触发器本质是方法。去掉get只有set就是只写属性
                                                                 去掉set只有get就是只读属性
                    自动属性：
                            ex：public int Height{get;set;}    //不做逻辑判断，可读并且可写


                ex: private int age; 
                    public int Age
                    {
                          get
                          {
                                return Age;  //在取值的时候触发，取到的值是return的值。
                                //或 return this.age;
                          }
                          set
                          {
                             Console.WriteLine("你刚才赋的值是："+value)   //赋值的时候触发的代码块
                                                                        // value 能在set中使用
                                //this.age = value 赋值给保存起来
                          }
                    }

                ex:死循环
                    private string name;
                    public string Name
                    {
                            get
                            {
                                return Name;
                            }
                            set
                            {
                                if (value == "毛泽东"){
                                    Name = "无名";
                                }else
                                {
                                    Name =value;   //死循环
                                }
                            }

                    }

        partial（部分）：用来修饰部分类，或者叫伙伴类。
                    用法：在同一个命名空间中写相同的类名，但是都用partial关键字修饰。
                    原因：c#编译器在编译的时候会将他们编译为一个类。所以在一个类中访问部分类的成员。
                    满足部分类的条件：
                        1：类名相同
                        2：在同一个命名空间
                        3：都被partial修饰

        null : 
            null是值，不是数据类型不是类。而且只能是引用类型的变量的值。
            作用：如果一个引用类型的变量值为null，代表引用类型的变量没有指向任何对象。 

        readonly： 
                1：readonly只读，只能用来修饰字段，不能修饰局部变量。
                                字段：类的成员变量。
                2：只能取值，不能改值。
                3：只读字段的值只能在构造函数中改变，其他地方不能改变。！！！
                4：与const的区别
                    const是在编译的时候确定。 //例如PI
                    readonly 是在运行的时候确定。 //例如用户输入的名字。
            
11：访问修饰符：成员的访问修饰符
                作用：限定成员在什么位置访问。
        public ： 公共的。被修饰的成员可以在任意的地方通过 对象. 出来访问。
        private（默认） ： 私有的。被修饰的成员只能在本类中通过 对象. 出来访问  或者直接用
                            不能实例之后用。


12：命名空间：
        1：命名空间中不能直接写方法。
        2：在同一个命名空间中不能写相同的类名，不同的命名空间可以写相同的类名。在使用是会提示你的。
        3:命名空间可以嵌套的。
         ex:   namespace room
            {
                namespace room2
                {


                }
            }
           或
           namespace room.room2
           {

           }   

        4：在同一个命名空间不能写同名称的类
            但是，如果相同名称的类都被partial关键字修饰就可以了，因为他们是一个类

13：构造函数：
        1:也是类的成员之一，是一个特殊的方法.
        2:构造函数没有返回值，void也没有。
        3:不能被程序员手动调用。
        4：在我们创建对象的时候 new 后面的小括弧 是在调用构造函数。
        5：构造函数可以重载。-- 重载：参数的个数或是类型不一样。
        方法名 必须与类名一致。
        语法: 访问修饰符（一般情况下是public）  函数名字（必须与所在的类名一致） ([参数列表])
                {

                } 
        构造函数的作用：
            1：创建对象的同时自动执行构造函数的代码。
        注意：不要在构造函数中写特别耗时耗性能的代码。
             一般为对象的属性或字段赋值。
            new的时候也可以使用对象的初始化器；
            ex: Student s1 = new Student(){name = "chen",age = 19};  //无参数的构造函数
                Student s1 = new Student {name = "chen",age =19};  //这个调用的是无参数的构造函数。
                Student s1 = new Student{}; //构造函数无参数。

                Student s1 = new Student ("chen" , 18);  //带参数的构造函数。没有用对象的初始化器
        
        隐士构造函数：
            如果我们没有为一个类写任何的构造函数，c#编译器就会自动生成一个无参数的空的构造函数，这个构造函数就是隐士构造函数。
            但是：当我们写了一个任意的构造函数的时候那么 c#编译器就不会生成无参数的构造函数。
            如果在有参数的构造函数的情况下非要用无参数的构造函数 就可以利用 重载 手动写一个无参数的构造函数。

        构造函数直接的调用：
            语法：在括号的后面加 : this ([参数列表])
            注意: 先调用其:this()的构造函数,如果A调用了B构造函数 则先执行B在执行A
                  不能一个同时掉两个，但是可以 一个调用一个 在调用另一个。
            ex:  class Student
                {
                    public Student() {
                        Console.WriteLine("我是无参数的构造函数。");
                    }
                    public Student(string a):this() {   //这里调用无参数的构造函数，无参数的构造函数先执行
                        Console.WriteLine("我是有参数的构造函数");
                    }
                }

                Student s = new Student("aaa");

            ex:
                public Student() {
                    Console.WriteLine("我是无参数的构造函数。");
                }
                public Student(string a):this(12) {    //调用int的构造函数
                    Console.WriteLine("我是有参数的构造函数");
                }
                public Student(int b):this() {         //再调用无参数的构造函数
                    Console.WriteLine("我是int");
                }
            构造函数之间的传参：
                ex:
                     class Student
                    {
                        private string name;
                        private int age;
                        private bool gender;
                        public Student(string name ,int age) {
                            this.name = name;
                            this.age = age;
                        }

                        public Student(string name , int age ,bool gender):this(name,age) {  //这样代码省了代码
                            //this.name=name;
                            //this.age=age;        省略了代码。
                            this.gender = gender;
                        }
                    }

14：常量const
        常量：被const修饰的数据叫做常量
            特性： 1：常量一旦声明他的值就无法修改；
                   2:我们声明一个常量的时候，编译器会将常量的那句话去掉直接用值代替，然后在使用到常量的值的地方用常量的值直接代替。
                   3：声明常量的同时必须赋值。 
                   4：常量的值要求在编译的时候就就要确定，给常量赋值的是时候不能有变量参与。
                      ex:  string str = "aaaa";
                         const string name = "jack" + str ;  // 报错 因为这里变量只有在编译的时候才知道冲突了

                      ex: const  str = "aaaa";
                          const  name = str + "bbbbb";  //这里可以 因为str是const编译的时候可以确定的。


            语法： 
                const 数据类型  变量名字  = 值 ;