小知识点:
        /***cmd编译.cs文件为.exe可执行应用程序:
                    1：C:\Windows\Microsoft.NET\Framework\ -- 下面有很多版本用最新得就行 找到 csc.exe 文件 配置环境变量
                    2：在cmd中敲命令： csc [.cs文件路径]  就会在同目录下生成同名得.exe 文件
                    3：        在cmd中直接运行.exe文件  c:> [.exe文件路径]
                            双击.exe文件  -- 但是会闪一下
                    解析csc 命令的作用:
                            首先要检查源文件中的代码是否符合C#语言规范. 如果符合 那么就将源代码生产为1个可执行文件.
                            如果不符合 就会提示错误 并大概的提示错误发生的地方  不会生产可执行文件.
        /***设置启动项目:  -- 这样得话方便
		            找到解决方案--》右击属性--》设置启动项 选择当前选定内容

        /***ctrl+shift+空格 可以强制提示--在把()打完之后没有提示了，就将光标放到括号里面在按快捷键就有提示了。

        /***CPU只会执行Main函数中的代码. 当CPU将Main函数中的代码执完毕以后,那么程序就自动结束了.main函数即使入口也是出口
        /***声明一个局部变量的时候，声明完以后始终没有用到这个变量那么c#编译器在编译的时候会将这个声明省略掉。
        /***为什么使用面向对象？
            修改维护几位方便。
        /***我们在为类声明字段并赋值的时候，编译器在编译的时候会在构造函数中赋值。
                因为字段赋值的代码，是执行代码，只有CPU执行才会有结果。
        /***函数的使用。注意没有默认值的形式参数要在最左边，方法的参数默认值&显示的为参数赋值
            ex:  public static void Test(bool flag,int num =12,string str = "jack"){
                    console.WriteLine(num+":"+str);
                }
                Test(flag:true,str:"rose");  //这样给指定的形式参数赋值
        /***常量const没有地址。因为在编译的时候变量全部用常量代替了。
        /***类中类，类里面可以在写类。但是这个时候类中类只能在父类中访问。
                相同的，枚举enum 也是一样的。   
        /***类库程序，程序集c#写的dll。
                类库程序没有Main函数入口，不能双击。
        /***面向对象的思维。
                ex:  人开门
                    class Person                class Door                    Main(){
                    {                           {                                    
                     public string name;          public string brand;          Person p =new Person();
                                                                                Door d =new Door();
                     public void OpenDoor(Door d)   public void Open()          p.OpenDoor(d)
                     {                             {
                           d.Open()                  console.log("门开了")
                      }                            }

                    }                             }                                }


        /***c#源代码 --> 程序集(exe,dll)  MSIL(微软中间语言)  -- > CLR公共语言运行时 (JIT即时编译器)  --> cpu
             c#编译器得作用：先检查源文件的语法是否正确。若正确就生成程序集
             程序集：只有.NET平台编译出来的.exe或dll才叫程序集，不是所有的exe,dll文件都叫程序集,
                    组成程序集的重要部分是MSIL
        /***静态成员
                静态成员属于类，实例成员属于对象。
                所以：类名.静态成员  来访问。
                      对象.成员来访问  实例成员。
                在创建对象的时候，是根据类的模板来创建的，静态成员除外。！！！
        /***利用.NET reflector 可以反向编译
        /***ILDASM可以用这个工具看程序集的中间语言是什么
         /***托管代码与非托管代码
                托管代码：运行的时候被CLR托管的代码，叫做托管代码
                非托管代码：运行的时候直接被系统运行
                区别：
                    1：安全性 
                        托管代码更为安全
                        托管代码开个空间，防止别的程序进来，限制自己出去这样安全
                    2：效率
                        托管代码大多数情况下运行效率比非托管代码高。因为程序集在运行的时候，JIT（根据环境，CPU。。。）会将程序集中的MSIL于洋
                        转换本地平台执行效率最高的二进制代码 
                        在第一次运行的时候，托管代码的效率比较低，只要系统不关闭
                    3：内存的管理
                        托管代码自动回收，非托管代码要主动释放。
        /***即使窗口的使用
                在调试模式下在即使窗口输入 &变量 就会输出地址。
        /***vs代码段的使用
                工具--》代码段管理器语言 选c# 出来路径 在路径下面就是放的代码段。
                自定义：按照其中之一的格式就可以了
        /***主动创建作用域:
                    {
                        string name ="cd";
                        console.WriteLine(name);
                    }       //执行完之后name被GC回收
        /***c#中的注释
                1:单行注释  //
                2：多行注释  /*
                             * 
                             */
                3：文档注释
                        ///<summary>
                        /// 这是注释字符
                        ///</summary>
                4.折叠注释
                        #regin 注释字符
                        #endregin
        /****计算机的存储
                计算机的存储空间主要分两个：栈空间和堆空间。
                            声明就是在栈空间  //值类型直接存储在栈空间
                            new 就是在堆空间  //引用类型栈空间存的是堆的地址。
        /***对象与类的区别
                对象是具体存在的可以直接使用，类是统称抽象的不能直接使用。
                类是模板，对象是根据这个模板创建出来的，模板上有什么那么对象中也就有什么，不多也不少。
        /***StringBuilder // 用这个在做大批量字符串拼接的时候效率会很高，应为SB对象只有1个。每次的追加是修改，没有创建新的。
                sb.Append();  //往sb对象中追加字符串。直接改变sb对象。
                sb.AppendLine();//追加字符串之后在加换行符。
                sb.AppendFormat();//使用占位符往sb对象中追加字符串。
                sb.Clear();  //清空字符串 
                sb.Insert();  //在指定的位置插入指定的值。直接改变原来的Sb对象。
            int i =sb.Length    //SB对象中保存的字符串长度。 --属性
                sb.Remove();  //从指定的位置删除，删除几个。
                sb.Replace();  //代替指定的字符或字符串。
         string str = sb.Tostring();  //返回Sb对象中保存的字符串

        /***Stopwatch 
                    查看运行的时间：
                        ex:Stopwatch watch = new Stopwatch();
                            watch.Start();
                            //代码块
                            watch.Stop();
                            console.WriteLine(watch.ElapsedMillseconds);  //打印时间。        
        /***Console类库
                    控制台接受用户的输入
                            String  a=Console.ReadLine();
                            ConsoleKeyInfo k=Console.ReadKey(); --  k.key  k.char
                
                    Console.WriteLine()的占位符
                            ex: Console.WriteLine("我{0},{1}","是","啊啊啊");
                                                第一个变量是0 ， 第二个是1 ... 
                                Console.WriteLine("我{0},{0}","是","啊啊啊");  -- 这样也行，只是有个变量没有用。
                    Console.Clear()   //清空控制台。。
                    Console.Beep();  //通过扬声器播放B的声音一次。默认声音
                    Console.Beep(500,2000); // 第一个参数是声音的频率就是调节是什么声音 ，第二个参数是播放的时常 这里表示2s播放频率为500的声音。
                    Console.Title = "aaaaa";  //设置控制台标题
                    Console.BackgroundColor = ConsoleColor.Blue;  //设置控制台的背景色为蓝色，这个仅针对字体的背景。。。
                    Console.ForegroundColor = ConsoleColor.Red;  //设置前景色，就是字体颜色
                    Console.ReadLine(),Console.ReadKey()  -- 暂停控制台程序

        /***获得随机数
                Random r =new Random();
                int num = r.Next (0,101); //   0=<num<101并且是整数

        /***数组类库
                数组反转:
                        Array.Reverse(arr) //直接改变数组
                判断数组里面时候有'a':
                        bool b= arr.Contains("a")   
                找数组中指定数据的下标:
                        int index = Array.indexOf(arr,"a")  //找到就是下标，没找到就是-1 --找的是最近的一个
                        int a =Array.LastIndexOf(arr,10);  //在有相同数据的情况下找最后一个的下标
                数组排序：
                        Array.Sort(arr);  //升序
                        要降序很简单，先升序，在反转。。。
                获取数组的行数或列数：
                        int i= arr.GetLength(传入行数或列数);
                数组求和：
                        int[] arr = { 1, 2, 3, 4 };
                         int a =arr.Sum();  //10
                        

        /***string类库
              string str=str.Trim()    //去掉字符串的首尾空格。。
               string str= str.TrimStart()  //去掉字符串前面的空格
               string str = str.TrimEnd()   //去掉字符串的末尾的空格
             int i = String.Compare()  //比较两个字符串的大小 如果第一个大于第二个就返回1，小于就是-1，等于就是0
                                       //比较字符从第一个比较起，如果相等就比第二个，依次下推。
                                       //如果是中文就比较拼音。
            int i  = str.ComperTo();  //实例方法。效果与String.Compare()相同。
              bool  b= str.Contains(); // 判断字符串是否包含某个字符或是字符串。
            string  str =  String.Concat();  //用来连接字符串。用“+”号其实就可以链接了，但是其实内部还是这个方法
             bool    b=  str.EndsWith();   //判断字符串是否以子串结尾。比如判断文件是否是MP3.。
             bool  b = str.StartsWith();    //判断字符串是否以字串开头。
             bool b =str.Equals();          //判断是否与传入的字符串是否相等。与 == 作用一样。
             string str= String.Format();    //就像占位符一样，使用一样。("hello{0}" , "我的世界")
             int i = str.indexOf();         //查找指定字符或字符串在字符串中的第一次出现的下标。如果是字符串的话，就是第一个字符出现的位置。
                                            //找不到返回-1
            int i =str.LastIndexOf();       //查找字符或是字符串最后一次出现的下标。
           string str= str.Insert();        //在指定下标位置插入字符串。因为字符串的恒定性，所以会返回新的字符串。
            bool b = String.IsNullOrEmpty();      //判断字符串是不是NUll或空
            bool b = String.IsNullOrWhiteSpace(); //判断字符串是不是null,空，空格（一个或多个）。
            string str =str.Remove();               //删除字符串。好用从指定位置删除。从什么开始我不要
                                                    //如果只传一个，那就是指定位置到最后
                                                    //传2个从那个开始删除，删除多少个。
            string str=str.Replace();           //改变字符串，替换指定的字符。或字符串。
            string[] strs=str.Split();              //分隔字符串。按指定的字符分割。可以传入多个，那就都分
            string str=str.SubString();        //分割，得到范围的字符串。从什么时候开始要。
                                                //截取，如果传入两个参数，从什么时候开始我要多少个。
            char[] chs=str.ToCharArray();       //将字符串转为Char数组。
            string str=str.ToLower();      //全小写，中文就原样输出。        
            string str=str.ToUpper();       //全大写



        /***int类库
                string转int
                   int i= int.Parse()是一种类容转换;表示将数字内容的字符串转为int类型。
                            如果字符串为空，则抛出ArgumentNullException异常;
                            如果字符串内容不是数字，则抛出FormatException异常; 
                            如果字符串内容所表示数字超出int类型可表示的范围，则抛出OverflowException异常;
                            int.TryParse 与 int.Parse 又较为类似，但它不会产生异常，转换成功返回 true，转换失败返回 false。
                            最后一个参数为输出值，如果转换失败，输出值为 0
                    bool b=int.TryParse(数值的字符串, 接受的变量) 其中第一个参数代表被转换的参数，第二个参数为转换后的参数 int类型，成功返回True，失败返回False。               
                        ex：int num;
                         bool b=int.TryParse(Console.ReadLine(),out num)  //转的int数值在num里面转成功b就是true
        /***GC类库
                GC.Collect();  //立即要求GC来回收堆空间的垃圾对象。

1：数据类型          
    值类型： -- 值是在栈里面
            整型：
                类型	    描述	                    范围	            默认值
                long	64 位有符号整数类型	-923,372,036,854,775,808 到 9,223,372,036,854,775,807	0L
                int	    32 位有符号整数类型	-2,147,483,648 到 2,147,483,647	0
                short	16 位有符号整数类型	-32,768 到 32,767	0
                sbyte	8 位有符号整数类型	-128 到 127	0
                byte	8 位无符号整数	  0 到 255  	0
                uint	32 位无符号整数类型	0 到 4,294,967,295	0
                ulong	64 位无符号整数类型	0 到 18,446,744,073,709,551,615	0
                ushort	16 位无符号整数类型	0 到 65,535	0
                char	16 位 Unicode 字符	U +0000 到 U +ffff	'\0'

            浮点型：
                类型	    描述	           范围	            默认值
                decimal	128 位精确的十进制值，28-29 有效位数	(-7.9 x 1028 到 7.9 x 1028) / 100 到 28	0.0M
                    注意：decimal类型的数据不能和其它的浮点型的数据参与算数运算
                        因为decimal类型的数据范围低，但是精度高。-- 懂？会丢失精度
                        但是可以和其他整形的数据参与算数运算。
                double	64 位双精度浮点型	(+/-)5.0 x 10-324 到 (+/-)1.7 x 10-308	0.0D
                float	32 位单精度浮点型	-3.4 x 10-38 到 + 3.4 x 10-38	0.0F
                    注意：如果我们直接在代码中写一个小数默认是double类型
                    double范围最广
                    decimal精度最高
                
            bool类型：
                 boole

            char类型：
                    char：
                            16 位 Unicode 字符	U +0000 到 U +ffff	'\0'
                            char可以存储单个字符，要用单引号引起来，空格也算字符
                            char类型的数据可以参与算数运算
                            
            enum枚举：

            struct结构体：
                    
    引用类型：--值都是在堆里面
            string ：  -- 他的值存在堆里面，但是是个特殊的引用类型！！！
                        存储多个字符，要用双引号引起来，可以没有也可以一个
                        1：string类型的字符串可以当作是一个字符(char)数组，是一个只读的数组。
                             还可以循环遍历每一个字符。
                        2：字符串对象存在字符串拘留池中，一旦创建，那么这个对象中的内容就无法改变
                        3：字符串一旦创建那么就不会被回收，哪怕是一个垃圾对象。
                            ex：string  str1 = "jack";
                                str1 = "Jim"
                        4:当我们新建一个字符串对象的时候会首先检查拘留池是否有相同的字符串，如果有就直接指向，不在创建
                        5：在修改字符串的时候，会新创建。
                    字符串的恒定性：不会变
                    1：通过构造函数创建字符串对象的时候，需要给一个字符串数组。可以看出字符串的本质是一个字符数组。
                    2：字段与属性。
                        a)length属性，可以得到字符的个数。
                        b)Empty静态的只读字段,注意是静态的。
                                string.Empty;  // 代表一个空的字符串对象。""
                        c)索引器：在索引器中传入1个下标 ，可以得到指定位置的字符。
                            ex: str[0];  // 只能取值不能赋值。
                    注意:在做字符串大批量拼接的时候，这个时候效率会很低下。
                        因为，每拼接一次都会去创建一个新的字符串对象。而创建对象比较缓慢。
                        于是出来了 StringBuilder。专门用来做字符串大批量拼接。
            数组：
                数组特性：数组中存储的数据类型必须一致，在创建的时候必须指定数组中存储的类型。
                        必须指定数组的长度。
                        数组有下表（索引）。
                语法：类型[] 数组名称=new 类型[存储的长度]; -- 声明数组
                        ex: int[]  arr = new int[3];
                    int[]  arr = new int[3]{1,2,3};    -- 声明并赋值
                    int[]  arr = new int[]{1,2,3,4};   --这里自动指定数组的长度，长度根据初始化器中的个数自动确定。
                    int[] arr= {1,2,3,4,5}              -- 简写
                数组的默认值：
                    数值类型的数组  --> 默认值是0
                    bool值类型的数组 -->默认值是fals
                    char类型的数组  -- > 默认值是'\0' 
                    string类型的数组 -- >默认值是null

            Array:

            class:

2:变量
    命名规则：
        1：以字母,_,@  开头不能以数字开头
        2：后面可以跟字母，数字，下划线
        3：驼峰命名，第一个小写其余单词首字母大写
        4：英文单词的缩写全大写
        5：c#大小写敏感
    变量的作用域：
        在一个大括弧中定义的变量只能在这个括弧中访问，出了大括弧就无法被访问。
        why:
            cpu在执行的过程中。如果执行完一个大括弧，那么大括弧中的变量会被系统垃圾回收。

    局部变量：定义在方法中的变量：只能在当前定义的方法中访问。--一直都是栈中。。
              在使用局部变量之前要赋值才能用。
              ex:  public static void name(){
                        int a =10;  //局部变量
                    }
    成员变量：定义在类中的变量：可以在整个类中访问！！！这个变量在new的时候存在堆中。。。
                成员变量在使用前可以不用赋值。--  使用的时候就是默认值。。
                                            值类型的默认值是:  0
                                           引用类型的默认值是：null
                如果要想被方法直接访问不传值。就可以加前面在static
                ex: 
                    class chen{
                            static int a =10;
                            public static void name(){
                                Console.WriteLine(a)   //这里能拿的到数据
                            }
                    }
                   
3：运算符和算数表达式和条件表达式
        注意：char类型的数据可以做算数运算，系统会将char类型的数据转成Unicode码再运算
        =  ：赋值运算符，将左边的值给右边的变量
        +  ：1：在字符串运算的时候是拼接字符串
             2：在做算数运算的时候是求和运算
        *

        / ：
            ex：int i =10;
                int j=3;
                i/j -- 结果不是小数，两个都是int 则算出来的就是int类型
        %
        +=,-=,*=,/=,%=
        ++ 自增
        -- 自减
        
        条件运算符：
            >
            >=
            <
            <=
            ==
            !=
            注意： <  <=  > >= 只能比较数值类型和char类型的数据
                    ==  != 所有的数据都可以比较
                    要比较就类型要一致或着兼容：
                        ex: string str ="123";
                            int i = 123;
                            str == i ;//报错 数据类型不兼容
        条件表达式：
            表达式的结果为bool值

        逻辑运算符：
            && : 逻辑与 两边的条件表达式都为true最终的结果才为true
                 如果做左边的为false,那么右边的就不会再看了。
                 ex: int i =4;
                     bool b= i++ > 10 && ++i >0;
                     Console.WriteLine(i)  // i=5  因为前面的i++ > 10 为false 所以左边的表达式系统就不会再看了
            || : 逻辑或
                    如果左边的表达式为true，那么右边的表达式就不会再看了。
                                    
            !  : 逻辑非
            逻辑运算符的优先级：! > && > || 
            ex:  int i=12;
                bool b = i +1 > -1 || i < -5  && i <10 ;//结果为true
                          i+1 > -1 ||  (i <-5 && i <10)  //实际先算&& 也就是括号里面的
                                    
        所有运算符的优先级：() > 单目运算符(!,++,--)  > 算数运算符 > 条件运算符 > 逻辑运算符
        算数表达式：
            算数表达式的结果类型？
                如果算数表达式的数据的类型一致，那么这个算数表达式的结果也是这个类型。
                如果不一致，那么表达式的类型是范围最大的那个。
            注意：浮点型的范围比整型的大
                  浮点型>long>int>short>byte
            ex: int i1=2100000000
                int i2=2100000000
                long i3=i1+i2    //结果不是42亿，因为表达式的结果为int类型 42亿溢出了。结果不是我们想要的
4:转义
        \n : 换行
        \b : 删除前面的字符
        \\ : 就是字符\
        \t : 制表符
        \r : 回车
        注意：字符串的前面加@之后，字符串可以换行，并且无论什么转义都会当字符串使用。

5：数据的转换
    1：自动转换（隐式转换）
        自动转换的条件：
            1：两种变量的数据类型相互兼容，所有的值类型之间相互兼容
            2：目标类型的范围要比源类型的范围大
                    注意：char类型的数据与数值类型兼容。char 相当于 int 类型
                    范围 ： double > decimal > float
            ex: byte b = 12
                int i = b  // 隐式转换   
    2：强制转换
        类型兼容：
            再数据类型兼容的情况下，我们不能直接将一个范围类型的变量直接赋值给1个小范围的数据类型的变量。因为有可能溢出。
            所以系统不直接帮我们转换。
            语法：
                小范围变量 = (强制转换的类型) 大范围的变量 
                ex: int i=20;
                    byte b = (byte) i;

                    int i = 97;
                    char c=(char) i; //a 成立
            强制转换溢出的情况：
                1：浮点型 -> 整型  只保留整数部分
                2：大 - > 小
                    ex: int i=268;
                        byte b= i ;//2 结果是溢出的部分。
        
        类型不兼容：
            parse转换：用来将字符串转成其他类型
            转换成功的条件：
                1：字符串的字面量是什么类型就转换成什么类型
                2：parse 只能转换字符串  -- char 类型的也报错
                    语法：
                        ex: String str = "123";
                        int num = int.Parse(str);

                        ex: string str = "123.123f";
                            float d= float.Parse(str); //报错
            
            convert转换：万能转化任意的数据都能用convert
                语法：
                    Convert.To类型(待转数据);
                              int === > int32
                              long ===> int64
                              short ===> int16
                              float ===> single
                                其他类型一致
                    ex : String str = "123" ;
                         int num = Convert.ToInt64(str);
                    
                    Convert与parse 的区别
                        1：convert 内部调用了parse 转换只是在前面添加了一个判断
                            ex:string str= null;
                            Int a =Convert.ToInt32(str)  //a =0;
                                但是parse转换则会报错
                        2：convert转换还可以做自动类型的转换，于直接赋值一样。
                            ex: byte b =12 ;
                                int i = Convert.ToInt32(b);
                                但是parse则会报错。
                        3：convert做强制转换：
                            ex: int i = 256;
                                byte b = Convert.ToByte(i)  // 会报错
                                发生溢出就报错。但是强制转换就不会报错。结果不是我们想要的就是了
                            将浮点型强制转换为整型：convert会对小数部分做4舍5入。但是 <= 0.5 都是舍
                                但是强制转换全部是舍。舍掉小数部分。
                            ex: 
                                double d = 12.51;
                                int i = Convert.int32(5) ; // 13
            
            tostring : 任意数据都能转成字符串 
                    语法： 
                       String str = 变量.ToString();

            

6: if结构，if-else结构，三目运算符，switch-case结构
    if语法：1:
              if(bool表达式){  //表达式的结果为bool类型
                //执行代码
                }
        
           2:if(bool表达式)          // 如果代码里面只有一句代码就可以省略大括号{}
                 执行的一句代码;
              else if (bool表达式)
                  一句代码;
            
            ex:
                if(a>0)          //这样写也是对的
                    if(a>9)
                        console.log("a>9")
                    else
                        console.log("0<a<9")
                else
                    console.log("a<0")
    if-else语法:
                if(bool表达式){

                }else{

                }
    三目运算符：
        语法：  bool表达式?值1:值2
        结果：如果bool表达式的结果为true那么三元表达式的结果为值1，如果bool表达式为false那么结果为值2
        注意：值1和值2的类型要一致。
              值1和值2还可一写成表达式，将表达式的值的值返回。
    switch-case语法：
            注意：case 后面的值 不能有变量的存在。！！！！
            switch(表达式/值/变量){   //这里面不能是浮点型！！！！！！
                case 值1:
                    执行代码1;
                    break;
                case 值2:
                    执行代码2;
                    break;
                case 值3:
                    执行代码3;
                    break;
                default:
                    执行代码;
                    break;
            }

            switch(表达式/值/变量){
                    case 值1:
                    case 值2:
                    case 值3:
                        执行代码;
                        break;
                    default:
                        break;
            }


7：循环结构 while  do-while for foreach
        while:
            语法：while(bool表达式){

                 }
            流程：先计算bool表达式的结果，如果结果为true则执行循环体，直到表达式的结果为false跳出循环。
                  break也可以跳出循环。
            ex:  while(pwd != "888888"){        //将退出条件写在这里。。

                }

        while中的break和continue:
                break:跳出循环
                continue:只能卸载循环体中，作用是立马结束本次循环。进入下一次循环。

        do-while:
            语法：do
                  {
                        //循环体
                  }while(bool表达式);
            流程：先执行一次循环体在判断bool表达式。。。
        for：
            语法：for(初始化表达式;bool表达式;循环操作表达式){
                        //循环体
                    }
            ex:for (int i = 0; i<10 ;i++){

                }
            注意：for循环的三个表达式都可以省略。但是分号不能省略。
                    for (;;){

                    }   // 死循环。
                    第一个表达式可以随便写。！！！
                    如果第二个表达式省略。那么循环的条件就是true。写的话只能是bool表达式。
                    ex:for(Console.WriteLine("A"); ;Console.WriteLine("B")){
                            Console.WriteLine("C")

                        }    // A B C B C B C ...  证明第一个表达式只有第一次执行
                    break在for循环中与while中一样，但是continue有点不同，在for中还是会执行操作表达式。！！！
        
        foreach:
            语法：foreach(数据类型 变量名 in 数组的名称){

                  }
8：try-catch
            try    -- 比较消耗性能
            {
                int b = 0;
                int a = 10 / b;  //这里异常  直接去执行catch的代码
                int c = 11;    //这里不会执行
                
            }
            catch (Exception e)
            {
                Console.WriteLine(e);       //打印全部
                Console.WriteLine(e.message);   //只打印信息
                
            }
            finally     //这个可以没有  无论如何都执行这段代码
            {
                    Console.WriteLine("不管有没有异常都执行"); 
            }

9：方法和return：
        语法:
            访问修饰符  [static(是否是静态的)] 返回值的类型 方法的名称([参数列表])
            {
                //方法体
            }
        位置：不能在Main函数中。应该定义在类中，与Main函数同级别。
        名称：每个单词首字母都大写。
        return :立即结束一个方法，并可以带返回值。return--只能在方法里面用
        方法传参：对于值类型的数据是按值传递，对于引用类型的数据是按地址传递。
                    简单点：按值传递之后的改变不会影响源数据。
                            引用类型的传递的改变就会源也会改变。
        方法中的switch：方法里面有return就不写break
               ex: public static int getresult(){
                    switch ("a"):
                    {
                        case "+":
                                return 10+10;      //不写break
                        case "-":
                                return  10+10;
                        default:
                                return 0;      //因为有返回值所有方法必须有返回值；也可以在外面写return 0;没有影响
                    }
                        
                }
        方法的重载：在一个类中可以定义多个同名的方法，但是必须保证参数的个数或者类型不一样。
                ex: public void name (){

                    };
                    public void name (bool b){

                    }

            

10：关键字：
        static:直接在内存中生成。可以直接在其他地方使用。--一直在内存中存在
                在program类中的成员变量，要想被Main函数访问就得加static.!!!
                    因为Main是static类型的函数。
                但是在其他类里面得成员变量可以不加static就被成员函数访问。
                ex:
                    class Person
                    {
                        private string name;
                        void Sing()
                        {
                            this.name = "陈冬";   //可以直接访问。也可以用实例对象.就可以出来
                        }
                    }
        new:   在内存中开辟空间，实例化类。
                new做的四件事：
                    1：在堆空间中开辟1块合适大小的空间
                    2：在这个空间中根据类的模板来创建对象，类模板中定义了那些成员变量，
                        就按照这个模板来在空间中逐个创建。
                    3：调用这个对象的构造函数。
                    4：返回这个空间的引用地址。
        using：引用命名空间这样就可以直接访问当中的类了。不用加命名空间的前缀了。

        this:指当前对象
                1:代表当前对象，通过它可以点出本类的所有的成员和父类的非私有成员；
                2：本类构造函数之间的调用。


        base:与this关键字一样，只能用在实例方法中。 -- 只显示父类的
               1： 通过base关键字，可以显示的访问父类的非私有成员。
               2：可以为子类的构造函数指定调用父类的哪一个构造函数。

        set和get： 属性 属性不能存值。。。实际有点像触发器本质是方法。去掉get只有set就是只写属性
                                                                 去掉set只有get就是只读属性
                    自动属性：
                            ex：public int Height{get;set;}    //不做逻辑判断，可读并且可写


                ex: private int age; 
                    public int Age
                    {
                          get
                          {
                                return Age;  //在取值的时候触发，取到的值是return的值。
                                //或 return this.age;
                          }
                          set
                          {
                             Console.WriteLine("你刚才赋的值是："+value)   //赋值的时候触发的代码块
                                                                        // value 能在set中使用
                                //this.age = value 赋值给保存起来
                          }
                    }

                ex:死循环
                    private string name;
                    public string Name
                    {
                            get
                            {
                                return Name;
                            }
                            set
                            {
                                if (value == "毛泽东"){
                                    Name = "无名";
                                }else
                                {
                                    Name =value;   //死循环
                                }
                            }

                    }

        partial（部分）：用来修饰部分类，或者叫伙伴类。
                    用法：在同一个命名空间中写相同的类名，但是都用partial关键字修饰。
                    原因：c#编译器在编译的时候会将他们编译为一个类。所以在一个类中访问部分类的成员。
                    满足部分类的条件：
                        1：类名相同
                        2：在同一个命名空间
                        3：都被partial修饰

        null : 
            null是值，不是数据类型不是类。而且只能是引用类型的变量的值。
            作用：如果一个引用类型的变量值为null，代表引用类型的变量没有指向任何对象。 

        readonly： 
                1：readonly只读，只能用来修饰字段，不能修饰局部变量。
                                字段：类的成员变量。
                2：只能取值，不能改值。
                3：只读字段的值只能在构造函数中改变，其他地方不能改变。！！！
                4：与const的区别
                    const是在编译的时候确定。 //例如PI
                    readonly 是在运行的时候确定。 //例如用户输入的名字。

        params:用来修饰方法的参数，但是只能修饰一维数组。
                特点：在调用params修饰的一维数组的时候，可以直接给一个数组，还可以直接给元素的值，每个元素,号分隔
                c#编译器在编译的时候就将数据封装到数组中去了。所以实参的个数仍然只有一个，传递的时候还是一个数组。
                ex:public static void GetHe(params int[] arr ){

                 }
                 GetHe(1,2,3,4,4,5,);  //其实编译器将这个new int[] 数组了。
                注意：1：被params修饰的参数要放在参数列表的最后面。！！！
                      2：被params修饰的参数在参数列表中最多只能出现一次。
                     3：在传参数的时候params修饰的参数可以一个也不传。
        ref:
            作用：用来修饰方法的参数。任意的参数都可以修饰，

            注意：
                    1：在传递的时候要是变量不能是常量。因为传递的是变量的地址。
                    2：  如果方法的参数被ref修饰那么，实参也要用ref修饰
                        ex: int num = 12;
                            TestRef(ref num);
                            public static void TestRef(ref int num){
                                    num++;
                            }           //最后num的值为13，这个时候传递的时候就是传递的地址。
                    3：被ref修饰的参数不能有默认值。
            使用：
                1：在要返回多个数据的时候。

        out:与ref类似。
           与 ref 区别：1：ref修饰的形式参数在方法的内部可以赋值也可以不赋值。
                            out修饰的形式参数在方法结束之前必须赋值。
                        2：ref在实参在传递之前必须要有值。 
                            out实参在传递之前可以没有值。
                        3:out侧重输出，ref侧重修改。
        
        sealed：被sealed修饰的类叫密封类，密封类不能被继承。

        is：判断类型
            1：变量的类型如果是A类型的，那么这个变量绝对是A类型的。
            2：如果这个变量指向一个子类对象，那么这个变量也是个子类类型的（同时是两个类型）。（里氏替换原则）
            3：变量的类型始终是1个父类类型的。 (object);
            4:is关键子只适合判断有继承关系的 （类才有继承）
            ex:
                Person p = new  Person();
                bool  b =  p is Person ;    //判断p是不是Person类型
                bool b1 = p is Object;
        
        as:也是用来做强制转换的； // 转换失败不报异常。返回null
            ex: Person p = new Person();
               Student  s = P as  Student；

11：访问修饰符：
        成员的访问修饰符 : 
                        作用：限定成员在什么位置访问。
                public ： 公共的。被修饰的成员可以在任意的地方通过 对象. 出来访问。
                private（默认） ： 私有的。被修饰的成员只能在本类中通过 对象. 出来访问  或者直接用
                                    不能实例之后用。
                internal：在同一个程序集中可以访问，无法跨程序集。就是一个项目。
                protected: 在类的外部无法访问，在类中通过对象名.出来可以访问。
                           还可以在子类内部中直接访问。  // 注意是直接访问。
                            ex: this.成员
                public > internal > protected > private
                子类的访问级别不能比父类的高。 

        类的访问修饰符：---没有private和protected
                    默认：internal
                public ：修饰的类可以在任意的地方访问。

                internal(默认) ： 修饰的类只能在当前程序集中访问。



12：命名空间：
        1：命名空间中不能直接写方法。
        2：在同一个命名空间中不能写相同的类名，不同的命名空间可以写相同的类名。在使用是会提示你的。
        3:命名空间可以嵌套的。
         ex:   namespace room
            {
                namespace room2
                {


                }
            }
           或
           namespace room.room2
           {

           }   

        4：在同一个命名空间不能写同名称的类
            但是，如果相同名称的类都被partial关键字修饰就可以了，因为他们是一个类

13：构造函数：
        1:也是类的成员之一，是一个特殊的方法.
        2:构造函数没有返回值，void也没有。
        3:不能被程序员手动调用。
        4：在我们创建对象的时候 new 后面的小括弧 是在调用构造函数。
        5：构造函数可以重载。-- 重载：参数的个数或是类型不一样。
        方法名 必须与类名一致。
        语法: 访问修饰符（一般情况下是public）  函数名字（必须与所在的类名一致） ([参数列表])
                {

                } 
        构造函数的作用：
            1：创建对象的同时自动执行构造函数的代码。
        注意：不要在构造函数中写特别耗时耗性能的代码。
             一般为对象的属性或字段赋值。
            new的时候也可以使用对象的初始化器；
            ex: Student s1 = new Student(){name = "chen",age = 19};  //无参数的构造函数
                Student s1 = new Student {name = "chen",age =19};  //这个调用的是无参数的构造函数。
                Student s1 = new Student{}; //构造函数无参数。

                Student s1 = new Student ("chen" , 18);  //带参数的构造函数。没有用对象的初始化器
        
        隐士构造函数：
            如果我们没有为一个类写任何的构造函数，c#编译器就会自动生成一个无参数的空的构造函数，这个构造函数就是隐士构造函数。
            但是：当我们写了一个任意的构造函数的时候那么 c#编译器就不会生成无参数的构造函数。
            如果在有参数的构造函数的情况下非要用无参数的构造函数 就可以利用 重载 手动写一个无参数的构造函数。

        构造函数直接的调用：
            语法：在括号的后面加 : this ([参数列表])
            注意: 先调用其:this()的构造函数,如果A调用了B构造函数 则先执行B在执行As
                  不能一个同时掉两个，但是可以 一个调用一个 在调用另一个。
            ex:  class Student
                {
                    public Student() {
                        Console.WriteLine("我是无参数的构造函数。");
                    }
                    public Student(string a):this() {   //这里调用无参数的构造函数，无参数的构造函数先执行
                        Console.WriteLine("我是有参数的构造函数");
                    }
                }

                Student s = new Student("aaa");

            ex:
                public Student() {
                    Console.WriteLine("我是无参数的构造函数。");
                }
                public Student(string a):this(12) {    //调用int的构造函数
                    Console.WriteLine("我是有参数的构造函数");
                }
                public Student(int b):this() {         //再调用无参数的构造函数
                    Console.WriteLine("我是int");
                }
            构造函数之间的传参：
                ex:
                     class Student
                    {
                        private string name;
                        private int age;
                        private bool gender;
                        public Student(string name ,int age) {
                            this.name = name;
                            this.age = age;
                        }

                        public Student(string name , int age ,bool gender):this(name,age) {  //这样代码省了代码
                            //this.name=name;
                            //this.age=age;        省略了代码。
                            this.gender = gender;
                        }
                    }

14：常量const
        常量：被const修饰的数据叫做常量
            特性： 1：常量一旦声明他的值就无法修改；
                   2:我们声明一个常量的时候，编译器会将常量的那句话去掉直接用值代替，然后在使用到常量的值的地方用常量的值直接代替。
                   3：声明常量的同时必须赋值。 
                   4：常量的值要求在编译的时候就就要确定，给常量赋值的是时候不能有变量参与。
                      ex:  string str = "aaaa";
                         const string name = "jack" + str ;  // 报错 因为这里变量只有在编译的时候才知道冲突了

                      ex: const  str = "aaaa";
                          const  name = str + "bbbbb";  //这里可以 因为str是const编译的时候可以确定的。


            语法： 
                const 数据类型  变量名字  = 值 ;
        修饰成员变量：
              public const string name = "jack";
              访问的话：直接类名.name就可以了。--但是与static是不一样的。

15：枚举：
        取值限定范围。
        语法： 
            1：枚举与类同级别，应该定义在命名空间下。
            2：
                ex:  enum 枚举名称{
                            枚举成员
                         }
        枚举与int之间的转换：
            ex: Direction dir = Direction.Up;
                int i = (int)dir;    //枚举转int

                int i = 0;
                Direction dir =(Direction)i;  //int 转枚举
        可以手动的指定每一个枚举值多对一的枚举数。用=号就行了。
        ex:
            enum a {
                    up = 10,
                    left = 1
              }
        注意：默认情况下枚举值所对应的数值类型是int类型。
            可以改：
            ex:      enum a:byte   //指定枚举值对应的数为byte类型
                    {
                        up = 10,
                        left = 1
                    }
        建议：在写枚举的时候，要加上自定义的数。从0开始也好。

        字符串转枚举：
            语法：(枚举的类型)Enum.Parse(typeof(枚举的类型),带转换的字符串);
            ex: a b = (a)Enum.Parse(typeof(a),"up");

16：结构体   --  与 类相似
        语法：
            struct 结构体的名称
            {
                //结构体的成员
            }
        位置：与类同级别。
        结构体中可以定义字段、属性、方法、构造函数。
        结构体对象也必须要创建对象来调用对象中的成员。
        结构体与类的区别：
            1：类是class声明，结构体是struct声明
            2：结构体中虽然可以声明字段但是声明字段的同时不能给字段赋值。
            3：结构体中可以定义构造函数，但是不能写无参数的构造函数。因为他自己带一个无参数的构造函数。
            4：结构体的构造函数中一定要给每一个字段赋值。
            5：在创建结构体对象的时候可以使用new关键字来创建，但是也可以不用new来创建。类必须用new实例化才能用。
                区别：1：通过new关键字来创建对象结构体中的字段就有值了，可以直接使用。是默认值
                      2：不用new关键字创建对象，结构体中的字段没有值。在使用字段之前必须赋值。

            6：结构体是一个值类型。类是一个引用类型。
               在赋值的时候是copy给另一个变量。结构体对象存在栈里面。
        什么时候用结构体：
            当我们表示一个轻量级对象的时候，栈的访问速度比较快。成员少的时候。

17：多位数组
        语法：元素的类型[,] 数组的名称 = new 元素的类型[行数,列数]
            ex: int[,] arr =new int[3, 4];
        数组的方法：-- 针对二维数组。。
           int i= arr.GetLength(传入行数或列数);
           ex:  int[,] arr =new int[3, 4];
                int a = arr.GetLength(0);   //3
                int a = arr.GetLength(1);   //4
        三位数组：
            语法：ex: int[,,] arr = new int[5,4,3];
                    arr[0,0,0] = 10 ;
        利用初始化其声明并赋值：
            ex: int[,] arr = new int[3,3]{{1,2,3},{4,5,6},{7,8,9}}   //三种方式
                int[,] arr = new int[,]{{1,2,3},{4,5,6},{7,8,9}}
                int[,] arr = {{1,2,3},{4,5,6},{7,8,9}}
        数组的Rank属性：
            int i = arr.Rank   ;  // 得到数组的维度。

        交错数组：本质是一个一维数组，只不过这个数组的元素的类型是一个数组类型 --- 当行确定 列不确定的时候用交错数组。
               int[][] arr = new int[3][];  // 声明了一个一维数组，这个一维数组长度是3，每个元素的类型是int[];
                                            //注意声明的时候，只需指定一维数组的长度就行了。
            ex: int[][] arr =new int[3][4];
                 arr[0] = new int[4];
                 arr[1] = new int[4];
                 arr[2] = new int[4];
                 arr[0][0] =12;
18:析构函数(C++叫终结者函数):
            语法:
                ~类名(){

                }
            注意: 析构函数不能带参数，不能带访问修饰符。
                析构函数在对象被GC回收的时候自动执行。
                是类的析构函数。  -- 死去的函数。
                      构造函数。  -- 出生的函数。

19：静态成员:被static修饰的成员叫做静态成员；
            静态成员不属于对象，属于类。 --！！！
            要访问的话：-- 要  类名.成员变量  来访问。
            当某一个类第一次被访问的时候，会将这个类中的所有的静态成员开辟在内存中。 
                
            创建在静态存储区中。 -- ！！！静态存储区专门用来存静态成员。
            静态成员创建一个。
            程序结束的时候，静态成员才被回收。---！！！
            使用场景：
                1：如果一个字段要被其他的类共享
                2：如果一个方法经常使用。
            局部变量不能被static修饰。
            在静态方法中不能直接访问实例成员和方法。要访问要加static或者实例化

    实例成员：没有被static修饰的成员。 -- 属于对象
            访问实例成员的话，要  对象.成员变量。
            实例成员在对象被创建的时候，随着对象一起被创建。
            创建在堆空间中。
            有几个对象就有多少个实例成员。
            对象被回收的时候成员对象就被回收。

20：静态类：
        static修饰的类叫做静态类。
            静态类中的成员，必须全部是静态成员。
            静态类不能创建对象。
            静态类中不能有实例构造函数。
21：静态构造函数：
        静态构造函数不能有访问修饰符和参数。
        语法：
            static 类名(){

            }
        什么时候执行：
            当类中的成员被第一次访问的时候，自动执行。 --注意是成员被第一次访问  Person  p;这个是不会执行的
            只会执行一次。
22：继承:
    语法： class 子类 ： 父类{   //父类又叫基类，子类又叫派生类

            }
    静态成员可以被继承，对象肯定访问不到。静态成员只有1份，由子类.静态成员访问。
    在创建子类对象的时候，会去调用父类的构造函数 ：  -- 可以打断点看见
        1：先调用子类的构造函数。
        2：再调用父类的构造函数。
        3：再执行父类的构造函数。
        4：最后执行子类的构造函数。
    构造函数不能被继承。！！！
    子类的构造函数默认情况下会去调用父类的无参数的构造函数。
    如果父类没有无参数的构造函数那么就要指定调用父类的哪一个构造函数。
    语法：
        public 子类 () : base("") {   //调用父类的构造函数

        
        }
    继承的特点：
        1：单根性：在c#中一个类只能有一个父类，不能同时继承多个类。
            一个类只能有一个父类，但是可以实现多个接口。
        2：传递性：A类从B类继承，B类从C类继承，那么A类就同时拥有BC类的成员。

    Object类是c#中所有类的祖宗类。
        如果我们不写继承类默认就从Object类继承。

    struct结构体之间不能继承。
        虽然结构提之间不能继承，但是每一个结构提默认都从ValueType类继承，ValueType在从Object继承。
        所以，我们创建结构体对象会有Object成员

    密封类和静态类不能被继承。！！！
            因为静态类没有实例构造函数，而在创建子类的时候要去调用父类的实例构造函数。
    
    在子类当中是可以存在和父类同名的成员。在调用的时候先找子类的
        在写相同的成员的时候，VS会提示隐藏了父类的成员，想不提示就加new关键字。

23：里氏替换原则(LSP)
    子类可以替换父类的位置。并且程序的功能还不受影响。
    解释：
        1：从类型转换的角度讲；子类与父类相互兼容，并且父类的范围比子类大
        2：从情理上讲
        3：程序功能不受影响，因为父类的成员子类都有。
    表现形式：
        父类变量指向1个子类对象。    
    如果一个父类变量指向一个子类对象，那么通过这个父类变量只能调用父类的成员，子类独有的成员无法调用
    ex：Person p1 = new Student(); 
        ex:object[]  objs=new object[3]
            objs[0] =12;
            objs[1]="str";
            objs[2]=new Person();
    
    强制转换将父类变量的值赋值给子类变量。
        a:强制转换发生的事情，将父类变量中的值强制的赋值给子类变量。（既是父类，也是子类）
            如果子类变量能够指向父类变量所指向对象的话，那么转换成功，否则转换失败。
            本类变量可以指向本类对象
            父类变量可以指向子类对象。
            
24:集合
        ArrayList(动态数组):
                count属性 --> 可以得到集合中元素的个数。
                1:是一个类，使用之前要new实例化。
                    ex: ArrayList list = new ArrayList();
                    int i=list.Add();  //向集合添加数据。类型是Object，如果是一个数组或是集合的话不像下面的，是直接存储一个数组。
                                        //返回存入数据的下标。
                    list.AddRange(); //可以传数组或集合。 将集合或数组中的元素打散后一个一个放入list中
                2：修改
                    ex : list[0] = "";
                3:删除元素
                    list.Remove();  //传入一个值，删除集合中第一个等于这个值的元素。
                    list.RemoveAt(); //删除指定下标的数据。
                    list.RemoveRange(); //删除指定范围的元素
                    list.Clear();   //清空集合中的元素。
                4：其他
                   bool b = list.Contains();  //判断集合中是否包含指定的元素。
                   int i =  list.IndexOf();  //查找指定元素的下标，第一个的下标
                            list.Insert();  //插入指定位置 ， 指定数据。
                     int i= list.LastIndexOf(); //查找最后一个指定元素的下标
                            list.Reverse();  //反转集合。
                            list.Sort();   //排序升序
                object[] obj = list.ToArray(); // 将集合转成object数组

        Hashtable(哈希表):哈希表的元素类型是DictionaryEntry
                count属性得到hash表中里面键值对的个数。
                长度动态增长。
                以键值对的形式来存储。
                键不能重复。因为键是区分每一个值的标志。
                Hashtable table = new Hashtable();
                1：添加：
                    table.Add();  //传入键值对来存储数据。两个都是Object。
                     table[键] = 值//这样也可以。没有才添加
                2：取值：
                    object obj = table[键]; // 取不到的话就是null
                3：改
                     table[键] = 值; //存在就是改
                4：删：
                    table.Remove(键); 
                    table.Clear();
                5：遍历
                        无法使用for循环

                       1: foreach(DictionaryEntry item in table){
                                item.key;  //键
                                item.value; //值
                        }                    

                       2: 哈希表有个属性叫做keys; //返回所有的键
                        所以只需遍历hash表中的keys属性就可以得到每一个Key；

                        foreach(object key in table.keys){
                                    key;//得到了
                        }

                       3: 还有个属性Values，这里面有所有的值。
                        foreach(object value in table.Values){

                        }

                6: 在往哈希表中新增的时候。新的数据不是按顺序进去的。在新增的时候，
                    会根据键和集合的长度做一个hash算法，算出一个下标。
                    在取值的时候，我们是根据key来取的，也会根据key来做hash算法。算出位置。
                7：其他
                   bool b = table.ContainsKey();//判断是否有键吗？
                   bool b =table.ContainsValue(); //判断是否有指定的值

                   