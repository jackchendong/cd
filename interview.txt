人事面试:
	1： 自我介绍
			答: 面试官好，我叫陈冬，来自湖北潜江，目前想需求一份nodejs开发的职位。
        2： 你觉得你工作中做的最成功的一件事情
			答:     1：目前没有，所以想找一个施展抱负的平台
				2： 我觉没有绝对的成功或失败，一定要说的话我认为有成功的选择，我认为我成功的选择就是选择了nodejs
	3： 压力测试，各种怼，比如: 你的简历3年不到换了4份工作我是不是可以理解为你不稳定，对工作充满了各种抱怨，是一个很不靠谱的人？
                        答: 我是一个没有棱角的人，相对比较谦和，我喜欢与人交流但不喜欢与人争，其实我觉得工作(核心把锅甩给别人)
        4： 即使是大公司也会有弊端
	                答: 思路 0： 有人的地方就有江湖，矛盾肯定存在
                                 1: 服从上级的安排
				 2： 在完成任务的情况下再去协商，交流
        5: 在大公司也会有加班,我们公司处在高速发展的阶段，也是要加班的，你不能接受加班咯？
	                答: 思路: 
				0： 现在的互联网不加班是不可能的，服务上线，bug修复这些是避免不了的
                               1：甩锅给小公司，混乱的加班，没有制度，条理
				2： 大公司一起发展的好处，公司是一艘船，员工就是水手，公司在飞速航行的时候水手是要出力的，当船到达彼岸的时候水手或获得丰厚的报酬，我愿意与贵公司携手前行，我愿意加班，但我不愿意很混乱没有条理的加班。
				3： 另外我在网上看到别人对公司的评价很好
        6: 你有什么想了解的吗？
		答:     1：公司的管理架构
                        2:  研发的规模
  			3： 五险一金的情况
                        4： 规章制度，就是上下班时间打卡，弹性
			5： 各种补贴 住房 车补 餐补
			6： KPI绩效啊
  			7： 调薪制度
			8： 年终奖，项目奖
			9： 加班调休
	问这些问题的原因: 表现的更大气，不是小白，是有工作经验的人
	
      人事的面试问题不要顺着思路来: 要变通一下
			比如: 你今天吃了啥？ 回答: 臭豆腐不好吃

技术面试: 
	1: 每隔两秒打印红 黄 蓝
		解法1:
		let i = 0;
		let sleep = async () => {
		    return new Promise((resolve, reject) => {
			setTimeout(resolve, 2000)
		    })
		}
		let start = async () => {
		    while (true) {
			let a = i % 3
			switch (a) {
			    case 0:
				console.log('红')
				break;
			    case 1:
				console.log('黄')
				break;
			    case 2:
				console.log('蓝')
						break;
			     default:
				 console.log(a + '错误')
				 break;
			}
			i++;
			await sleep()
		    }
		}
		start()
	
		解法2:
			let i = 0
			setInterval(function () {
			    i++
			    console.log(i)
			}, 1000)

	2: 链表 o(n)时间复杂度 查询倒数第5位

	3: 悲观锁和乐观锁是什么，什么时候用?
		答:
			悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

			乐观锁： 总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

			两种锁的使用场景： 从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

	4：服务器部署的时候，函数执行了一半，怎么解决
