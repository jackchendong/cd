0: 数据存储内存中
	1: 数据栈 BSS : 全局数据
	2: 栈空间 : 局部变量，函数调用
	3: 堆空间 : new 相关

    组织形式: 
	      1：开辟连续的内存空间 申请 -- 数组，连续内存空间，事先知道大小
	      2：分散空间，申请次数无限制，每次固定大小
		 开辟一个一个空间 -- 用指针连接起来形成连续的串，形成 -- 链表

1: 链表的时间复杂度和空间复杂度
	时间复杂度: 耗费的时间 与数据量的关系
	空间复杂度: 占用的内存 与数据量的关系

	1+2+ ... + n  o(n)
	n个数的n的平方次  o(n^2)
	与n的个数无关  0(1)  固定的时间

2: 数组（线性表）及其应用
	在计算机内存组织中只有两种数据存储的基本方式：数组和链表
	(1)数组的管理
		int a[100]; //在栈内存中申请100个连续的sizeof(int)空间
		int *p = malloc(100 * sizeof(int)); // 在堆空间中申请1000个连续的int空间
	  
		要对空间进行访问: 得到第10个成员 a[10] O(1)的成员访问时间
				  例如这100个空间是无序的。查找某个数必须遍历 0--99次
				  如果要在这100个空间中插入或删除一个数组。需要将后面的所有的成员后移或前移
	(2) 数组的应用
		查找表: 基本不会添加删除，可以一次性的访问某个成员，借助了数组下标的优越性
		具体应用: 要得出0~127这些范围中某个数的二进制码，从低位开始，第一次出现1的bit位编码号
		          3 --->>  0000 0011  值是 bit0
			  4 --->>  0000 0100  值是 bit2
		简单的办法: 
			data & 0x01 == 1 就是bit位编号
			否者 data >> 1 循环检查
			虽然最多比较7次，但是我们仍然没有办法绝对的固定这个值得时间
			可以构建一个表:
				a[128] = {-1,0,1,0,2,0,1,0,3...}
				ret = a[n]
				能够在确定的时间内得到期望的结果，缺点是: 事先就要构建表，占用内存空间，

3: 链表
	head --> 节点 --> 节点 --> ... -->null
	      next 指针
	节点: 固定大小的具有多个成员的结构体对象
	      1: 每一个节点需要存放数据,具体就是应用场景决定
	      2: 指向下一个成员的地址，指针
